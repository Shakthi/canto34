<!DOCTYPE html>  <html> <head>   <title>canto34.js</title>   <meta http-equiv="content-type" content="text/html; charset=UTF-8">   <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">   <link rel="stylesheet" media="all" href="docco.css" /> </head> <body>   <div id="container">     <div id="background"></div>          <ul class="sections">           <li id="title">             <div class="annotation">                 <h1>canto34.js</h1>             </div>         </li>                              <li id="section-1">             <div class="annotation">               <div class="pilwrap">                 <a class="pilcrow" href="#section-1">&#182;</a>               </div>                           <p>Canto 34 is a library for building recursive-descent parsers.</p>

<p>When it comes to writing a parser, you get two main choices. Write your
own, or use a parser generator like PEGJS or Jison. I've never really had
much success with parser generators, and it's always seemed pretty easy to
write a recursive-descent parser yourself, <em>if</em> you have some basic tools
like a regex-based lexer, and some basic functions for matching tokens and
reporting errors. Canto34 gives you the functions you need to write a
recursive descent parser yourself.</p>

             </div>                          <div class="content"><div class="highlight"><pre>
(function(canto34){

</pre></div></div>                      </li>                              <li id="section-2">             <div class="annotation">               <div class="pilwrap">                 <a class="pilcrow" href="#section-2">&#182;</a>               </div>                           

<p>your code goes here</p>

             </div>                      </li>                              <li id="section-3">             <div class="annotation">               <div class="pilwrap">                 <a class="pilcrow" href="#section-3">&#182;</a>               </div>                           

<p>A <em>Lexer</em> takes a string and chops it into pieces. A Canto34 Lexer is a series of pattern objects, like </p>

<pre><code>{ 
    name: "whitespace",
    regexp: "[ \t\r\n]+",
    ignore: true
}
</code></pre>             </div>                          <div class="content"><div class="highlight"><pre>	canto34.Lexer = function() {
		this.patterns = [];
	};

    var PatternDefinitionException = function(message) {
    	this.message = message;
    }

	canto34.Lexer.prototype = {
		addPattern: function(pattern) {
			if (!pattern.name) {
				throw new PatternDefinitionException(&quot;Patterns must have a &#x27;name&#x27; property&quot;);
			}

			if (!pattern.regexp) { 
				throw new PatternDefinitionException(&quot;Patterns must have a &#x27;regexp&#x27; property&quot;);
			}

			if (pattern.regexp instanceof RegExp) { 
				throw new PatternDefinitionException(&quot;Patterns &#x27;regexp&#x27; property must be an instance of RegExp&quot;);
			}
		}
	};

})(typeof exports === &#x27;undefined&#x27;? this[&#x27;canto34&#x27;]={}: exports);

</pre></div></div>                      </li>              </ul>    </div> </body> </html> 